name: Docker Multi-Build

on:
  repository_dispatch:
    types: [base-image-released]  
  release:
    types: [published]            
  workflow_dispatch:              

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ghcr.io/sferro-besmart/SmartModelV2
  REPO_SOURCE_URL: https://github.com/sferro-besmart/SmartModelV2  
  BASE_IMAGE_REPO: ghcr.io/sferro-besmart/my-rstudio
  BASE_GITHUB_REPO: sferro-besmart/my-rstudio

jobs:
  build:

    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Install Cosign
        if: github.event_name != 'pull_request'      
        uses: sigstore/cosign-installer@v3.8.1
        with:
          cosign-release: 'v2.4.3'

      - name: Check install!
        run: cosign version

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log into GitHub Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch Latest Release Tag from Base Image Repo
        id: get_base_version
        env:
          BASE_GITHUB_REPO: ${{ env.BASE_GITHUB_REPO }}
        run: |
          echo "Fetching latest release tag from Base Image Repo..."
          BASE_VERSION=$(curl -s "https://api.github.com/repos/${BASE_GITHUB_REPO}/releases/latest" | jq -r .tag_name)
          if [ "$BASE_VERSION" = "null" ] || [ -z "$BASE_VERSION" ]; then
            echo "No release found; defaulting to 'latest'."
            BASE_VERSION="latest"
          fi
          echo "BASE_IMAGE_VERSION=$BASE_VERSION" >> $GITHUB_ENV
          echo "Using BASE_IMAGE_VERSION=$BASE_VERSION"

      - name: Fetch Latest Release Tag from This Repo
        id: get_final_version
        run: |
          echo "Fetching latest release tag from This Repo..."
          FINAL_VERSION=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases/latest" | jq -r .tag_name)
          if [ "$FINAL_VERSION" = "null" ] || [ -z "$FINAL_VERSION" ]; then
            echo "No release found; defaulting to 'latest'."
            FINAL_VERSION="latest"
          fi
          echo "FINAL_IMAGE_VERSION=$FINAL_VERSION" >> $GITHUB_ENV
          echo "Using FINAL_IMAGE_VERSION=$FINAL_VERSION"

      - name: Validate Build Arguments Before Proceeding
        run: |
          echo "Validating required build arguments..."
          if [[ -z "${{ env.BASE_IMAGE_REPO }}" || -z "${{ env.BASE_IMAGE_VERSION }}" || -z "${{ env.REPO_SOURCE_URL }}" ]]; then
            echo "‚ùå ERROR: One or more build arguments are empty!"
            exit 1
          fi
          echo "‚úÖ All build arguments are valid!"
          echo "üîπ BASE_IMAGE_REPO: ${{ env.BASE_IMAGE_REPO }}"
          echo "üîπ BASE_IMAGE_VERSION: ${{ env.BASE_IMAGE_VERSION }}"
          echo "üîπ REPO_SOURCE_URL: ${{ env.REPO_SOURCE_URL }}"
          
      - name: Build and push final image (STUDIO)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Instal/Dockerfile.bsm-studio
          build-args: |
            BASE_IMAGE_REPO=${{ env.BASE_IMAGE_REPO }}
            BASE_IMAGE_VERSION=${{ env.BASE_IMAGE_VERSION }}
            REPO_SOURCE_URL=${{ env.REPO_SOURCE_URL }}
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ env.FINAL_IMAGE_VERSION }}
            ${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Sign the published Docker image
        if: ${{ github.event_name != 'pull_request' }}
        env:
          FINAL_IMAGE: ${{ env.IMAGE_NAME }}:${{ env.FINAL_IMAGE_VERSION }}
        run: |
          echo "Signing Docker image: ${FINAL_IMAGE}"
          cosign sign --yes ${FINAL_IMAGE}
          
